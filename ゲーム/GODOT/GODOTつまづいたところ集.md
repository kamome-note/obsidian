『両手いっぱいに芋の花を』制作者の記事。

Godot Engineでつまづいたところ集 1
https://note.com/nwsnkn/n/nc6f21fd809d2
Godot Engineでつまづいたところ集 2
https://note.com/nwsnkn/n/nf56a2ee381ef
Godot Engineでつまづいたところ集 3
https://note.com/nwsnkn/n/n3fc346ddf25f

---

**設定画面の見間違い**  
エディター設定とプロジェクト設定は、設定画面がぱっと見似ている。探している項目が見当たらない時は、間違えて別の画面を開いている。  
あるある。

---

**count回ループするfor文**  
for文でcount回ループするときは、`for i in range(0, count)`。  
`for i in [0, count]`は間違い。この場合、inの右の部分は0とcountの2要素からなる配列になってしまう。2回しかループしない。

---

**配列の配列**  
Arrayは中身を型指定できるが、型のネストはできない。例えば`Array[Array[MyClass]]`はNG。  
MyClassの2次元配列を型安全に使いたければ、X×Yサイズの`Array[MyClass]`で代替するしかなさそう。

---

**enumはクラスに属す**  
enumは他クラスで定義していても、ちゃんと使用可能。例えば、`MyClass.MyEnum.ENUM_ITEM_0` のように書く。  
ちなみに、未保存でも構文解析して評価してくれるVSのインテリセンスと違って、`my_class.gd`側をちゃんとファイル保存していないと、「そんなenumは無い」とエディタに怒られる。これはenumに限らず、クラスや関数の定義でも同様。

---

**コードエディタの矩形選択**  
GDScriptのエディタは、普通のテキストエディタのように、マウスによる矩形選択はできない。その代わり、Shift + Ctrl + カーソルキーで、矩形選択できる。ただし、操作は慣れるまで少し難しい。

---

**「参照の検索」は無い**  
GDScriptのエディタは、VSのような「参照の検索」機能が無い。なので文字列による検索を頼ることになる。コードもそれを意識した書き方をしたほうがよさそう。  
ちょっと冗長に書いたほうがいい。Cellクラスのメンバ変数`_cell_index`、これはC#なら`_index`に直したくなる。だが、"`index`"というワードはいろんなクラスや関数で使うだろう。なので、`_cell_index`のほうが、検索性が上がる。  
（関係無いけど、<u>indexはidxと略して書いたほうがGodot風</u>である）

---

**`_ready`と`_init`** 
`_ready`はノードがシーンツリーに追加されたときに呼ばれる関数。UnityのStart関数のようなものであって、コンストラクタ的なものではない。Objectのnew時に呼ばれるのは`_init`。こっちがいわば、コンストラクタ。

慣れるまでは何度か間違える。非ノードクラスに`_ready`を定義してしまっても何もワーニング等出ないので、誤りに気付かないことも。

- `_init`: コンストラクタ  
- `_ready`: ノードの初回更新時に呼ばれる  
- `_process`: ノードの更新  
- `_update`: そんな関数は無い  
- `_proc`: こんな関数も無い

---

**あえてオーバーライド前の関数を呼ぶ**  
親クラスの同関数をオーバーライド先のクラスから呼ぶには、キーワード"`super`"を使って"`super.my_func()`"と書く。  
ちなみにGodot3では、ドットだけを使って"`.my_func()`"のように呼ぶ書式だったが、Godot4でsuperに変わった。わかりやすくなった。

---

**整数の割り算はワーニング対象**  
整数同士の割り算をしようとすると、「余りは捨てられるけどいいの？」とワーニングが出る。奇妙に感じるメッセージだが、これはPythonユーザーを意識したワーニング。Pythonは整数同士の割り算で自動的にfloatになる仕様なので。  
プロジェクト設定から、このワーニングをオフにできる。もしくは、floatにキャストしてから割り算をして、intにキャストしなおすことでも回避できる。

---

**enumでループ**  
C#のようにenumでforeachしたい場合、`for mode in Enemy.Mode:`とやると、名前:Stringでループしてしまう。`for mode in Enemy.Mode.values():`とすれば、enumの値:intでループされる。  
ちなみに、どうやらenumの値は暗黙にintのようで、とくにキャストとかせず、`my_array[mode]`などのように、配列の添え字に使用可能。

---

**Blenderのバージョンは古いとNG？**  
blendファイルのインポートで`ERR_FILE_CANT_OPEN`エラーが出て上手くいかないときは、Godotが参照しているBlenderのexeのバージョンが、ファイルよりも古い。  
さらにどうやら、ファイルに対してBlenderのバージョンが「新しくても」エラーが出る（のかもしれない）。Blender3.2で保存したファイルを3.4のexe設定で開こうとしてもエラーが出た。

---

**テスト実行とシーンエディタ**  
<u>エディタ上のゲーム実行（UEの用語で PIE = Play In Editor ）の話</u>。  
Godotはエディタ上で実行中に、<u>ライブなシーンの状態をビジュアル的に見ることができない</u>。UnityやUEのエディタは、PIE中にワールドの状態をエディタ上で可視化する。それがない。

確かに、ツリーのヒエラルキーや各ノードのパラメータは、シーンタブの「リモート」を選択することで見ることができる。しかし一方で、シーンエディタに映っている映像は、PIEの状況を視覚的に表したものではない。そもそも、この画面はシーン（tscnファイル）を編集するためのもので、デバッグする用途ではないのだ。

なので、<u>PIE中に編集画面上で何も動いていないのは、正常</u>である。これは多分Unityとかやってた人は、最初引っかかると思う。

結局、ゲーム画面で確認するしかない。一応救済機能がある。エディタには、「プロジェクトカメラのオーバーライド」というボタンが備わっている。カメラのアイコンだ。それをオンにすると、PIEのゲーム画面が強制的に、シーンエディタ上の視点で描画されるようになる。PIE中にエディタの視点を動かすと、ゲーム画面の視点にリアルタイムに反映される。これがデバッグ機能として想定されているようだ。

---

**コード生成メッシュのワイヤーフレームを見る方法**  
通常、メッシュはシーンエディタ上でワイヤーフレーム表示することができる。しかし、ランタイムで動的に作成したArrayMeshは、通常はワイヤーフレームで見る手段が無い。なぜなら前述の通り、実行中の状態はエディタで見ることができないから。  
どうしてもエディタ上で形状を確認したければ、<u>@toolを先頭に付けたデバッグ専用のビューワーシーンを作成する</u>アイデアがある。ビューワーシーンの_ready内でメッシュを作成すればよい。

---

**デフォルトの背景色の落とし穴**  
StandardMaterial3Dを作成して、<u>デフォルト値のまま使用すると</u>、ノーマルの無いメッシュなどは、<u>カメラの背景色のデフォルト値（暗い灰色）とまったく同じRGB値で描かれる</u>。<u>結果的に何も映ってないように見える</u>。これは、知ってないと「なぜオブジェクトが見えない？」となる。映ってないのではなく、背景と同化しているだけだ。

カメラの背景色のデフォルト値（暗い灰色）は、「アンビエント以外でライティングされていない白い物体の色」なのだ。そういう仕様にした経緯はなんとなく解るけど、慣れるまではデフォルト値は変えてしまったほうがいい。  
<u>プロジェクト設定の、「レンダリング＞環境＞デフォルトのクリア色」から変更可能</u>。

---

**エディタ実行コードとstatic関数**  
@toolを先頭に付けたデバッグ用のシーンでは、class_name経由で他の自作クラスのstatic関数をいきなり呼び出すことができない。"Invalid call, Nonexistent function" のエラーになる。スクリプトをloadすればいけそう。

---

**play関数の引数**  
AnimationPlayerノードのplay関数の引数となるのは、"ライブラリ名/アニメーションキー名"。例えば、"`MyAnimLib/Evade`"。"`Evade`"だけではだめ。  
AnimationLibraryの`get_animation_list()`で返ってくるのは、アニメーションキー名だけなので、これにライブラリ名とスラッシュを付ける必要がある。

---

**マテリアルのパラメータ、個別変更**  
Unityでは、特定のオブジェクトだけマテリアルのパラメータを変えたい場合、明示的にマテリアルのコピーを作るか、`MeshRenderer.material`の副作用を使って一時的なマテリアルを暗黙に作成していた。マテリアルの複製が必要なのは、Godotでも同様である。しかし、Godotでは、マテリアルはメッシュに紐づいている。ということは、たとえマテリアルをコピーしても、メッシュに直接セットしては、同じメッシュを使っているインスタンスノードはすべて見た目が変わってしまう。

メッシュに紐づいているマテリアルは、いわばメッシュの「デフォルトマテリアル」なのだ。だから動的にマテリアルを変更するには、これを変えるのではない。デフォルトを隠ぺいして上書きする手段が別途用意されている。それが、`GeometryInstance3D. set_surface_override_material()`だ。

これでノードにマテリアルをセットすることで、描画に使われるマテリアルが変更される。もちろん、マテリアルのコピーは自分で事前にやっておく必要がある。コピーしたマテリアルは自分のコードで保持しておいてもいいが、`get_surface_override_material()`でセット済みのものを再取得することもできる。（`get_surface_override_material()`は、ソースコード見る限り、簡単なエラーチェックの後にメンバ変数をreturnしているだけなので、パフォーマンスも問題無さそう。）

ちなみに、`GeometryInstance3D. material_overlay`というプロパティもある。名前が似ていてこちらにもマテリアルをセットできるので、つい混同してしまう。が、まったく別物。こちらは上塗り表現用のもの。バリアやサビ、濡れの表現などに使えるだろう。

